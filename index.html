<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Comparison of MiniApps and web apps</title>

<script async class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>

<script class="remove">
var respecConfig = {
  specStatus: "unofficial",

  shortName: "miniapp-comparison",
  noRecTrack: true,
  edDraftURI: "https://xfq.github.io/miniapp-comparison/",

  editors: [
    {
      name: "Fuqiao Xue",
      company: "W3C"
    }
  ],

  wg: "MiniApps Ecosystem Community Group",
  wgURI: "https://www.w3.org/community/miniapps/",

  github: "xfq/miniapp-comparison"
};
</script>
</head>

<body>
<h1 class="title p-name" id="title">Comparison of MiniApps and web apps</h1>
<div id="abstract">
  <p>This document summarizes the differences of MiniApps and web apps.</p>
</div>

<div id="sotd">
</div>


  <section id="overview">
    <h2>
      Overview
    </h2>

    <p>
      This document summarizes the differences of MiniApps and web apps. Although the API and implementation of each MiniApp platform are different, due to time constraints, the editor can only summarize a subset of them.
    </p>

    <p>
      MiniApps usually need to be reviewed by the hosting platform to go online, and web apps just need to have a web server (and optionally a domain name) to go online.
    </p>
  
    <p>
      MiniApp development includes global configuration files and page configuration files. The configuration files are usually in JSON.
    </p>

    <p>
      See <a href="https://w3c.github.io/miniapp/specs/packaging/#packaging">MiniApp Packaging</a> for a typical example of directory structure of a MiniApp.
    </p>

    <p>
      The running environment of MiniApps is divided into a view layer and a logic layer. The view layer only deals with rendering and listens out for the events happening. The logic layer only deals with data and logic.
    </p>

    <figure id="fig-view-logic">
      <span style="text-align:center;"><img src="images/view-logic.svg" alt="The view layer and the logic layer." width="600"></span>
      <figcaption>
        The commnication between the view layer and the logic layer.
      </figcaption>
    </figure>

    <p>
      The logic layer is usually written in JavaScript. It processes the data and sends it to the view layer, and receives feedback from the view layer.
    </p>

    <p>
      Although using Web technogolies, MiniApps usually does not run in the browser, so some capabilities of JavaScript in the Web are not available, such as <code>document</code> and <code>window</code>.
    </p>

    <p>
      In a web app, rendering and script can block each other, which is why a long script running may cause the page to become unresponsive, but in a MiniApp, the two are separated and run in different threads. Web page developers can use the DOM APIs exposed by the browsers to do DOM manipulation. But since the logic layer and view layer of a MiniApp is separated, the logic layer (running in <a href="https://developer.apple.com/documentation/javascriptcore">JavaScriptCore</a>, for example) does not contain a <code>document</code> or <code>window</code> object, and can't use some web APIs. Therefore, some libraries like jQuery cannot run in MiniApps. Moreover, since the JavaScriptCore environment is not the same as Node.js, some npm packages cannot be run in MiniApps either.
    </p>

    <p>
      In the [[[#view]]], the host environment will convert the layout language (WXML, for example) into a JavaScript object. When data changes in the logic layer, the data is passed from the logic layer to the view layer through a method provided by the host environment, and then the diff of the DOM before and after is generated. After that, the differences will be applied to the original DOM tree and render the changed UI.
    </p>

  </section>

  <section id="view">
    <h2>
      View layer
    </h2>
  
    <p>
      There is usually a template language/mechinism (such as <a href="https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxml/">WXML</a>, <a href="https://smartprogram.baidu.com/docs/develop/framework/dev/">swan</a>, <a href="https://opendocs.alipay.com/mini/framework/axml">AXML</a>, <a href="https://microapp.bytedance.com/docs/zh-CN/mini-app/develop/framework/view/ttml">TTML</a> etc.) for the view layer of the MiniApp pages, which is similar to HTML in Web development. The MiniApp runtime translates the template language into HTML (each page is rendered in a different WebView, but all WebViews shares the image cache) or native code.
    </p>

    <p>
      When styling a MiniApp page, CSS is usually used, sometimes with <a href="https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxss.html">extensions</a> like new units.
    </p>

    <p>
      The elements used in the view layer are described in the [[[#components]]] section.
    </p>

    <p>
      Here are some examples:
    </p>

    <section>
      <h2>
        Example 1
      </h2>

<pre class="example html" title="Example view layer in Baidu Smart Programs">
&lt;!-- xxx.swan -->
&lt;view>
  Hello My {{ name }}
&lt;/view>
</pre>

<pre class="example js" title="Example logic layer in Baidu Smart Programs">
// xxx.js
Page({
    data: {
    name: 'SWAN'
    }
});
</pre>

</section>

<section>
  <h2>
    Example 2
  </h2>

<pre class="example html" title="Example loop in Baidu Smart Programs, view layer">
&lt;view>
    &lt;view s-for="p in persons">
    {{p.name}}
    &lt;/view>
&lt;/view>
</pre>
  
<pre class="example js" title="Example loop in Baidu Smart Programs, logic layer">
Page({
    data: {
    persons: [
        {name: 'superman'},
        {name: 'spiderman'}
    ]
    }
});
</pre>

</section>

<section>
  <h2>
    Example 3
  </h2>

<pre class="example html" title="Example control flow in Baidu Smart Programs, view layer">
  &lt;view s-if="is4G">4G&lt;/view>
  &lt;view s-elif="isWifi">Wifi&lt;/view>
  &lt;view s-else>Other&lt;/view>
</pre>
    
<pre class="example js" title="Example control flow in Baidu Smart Programs, logic layer">
Page({
    data: {
    is4G: true,
    isWifi: false
    }
});
</pre>

</section>

<section>
  <h2>
    Example 4
  </h2>

<pre class="example html" title="Example reactive data-binding in WeChat Mini Programs, view layer">
&lt;view> Hello {{name}}! &lt;/view>
&lt;button bindtap="changeName"> Click me! &lt;/button>
</pre>
    
<pre class="example js" title="Example reactive data-binding in WeChat Mini Programs, logic layer">
// This is our data.
var helloData = {
  name: 'WeChat'
}

// Register a MiniApp page.
Page({
  data: helloData,
  changeName: function(e) {
    // sent data change to view
    this.setData({
      name: 'MiniApp'
    })
  }
})
</pre>

<p>
  The user agent binds the <code>name</code> in the data in with the <code>name</code> in the view layer, so when the page is loaded, it will display "Hello WeChat!".
</p>

<p>
  When the button is clicked, the view layer will fire an event for <code>changeName</code> to the logic layer, and the logic layer will find and execute the corresponding event handler.
</p>

<p>
  After the callback function is triggered, the logic layer changes the name in the data from WeChat to MiniApp. Because the data and the view layer have been bound, the view layer will automatically change to "Hello MiniApp!".
</p>

</section>
  
  </section>


<section id="components">
    <h2>
      Components
    </h2>
  
    <p>
      MiniApps usually prohibit the use of some HTML elements, and add some new components (elements), such as <a href="https://swiperjs.com/demos/">swipers</a>, commonly used icons (warning, search, setting, loading etc.), maps, rich text editors, advertisement and so on.
    </p>

    <section id="custom-components">
      <h2>
        Custom components
      </h2>

      <p>
        MiniApp developers can also create custom components. Here's an example directory structure with a custom component in a Baidu Smart Program:
      </p>

<pre class="example" title="Example project including custom components in Baidu Smart Programs">
  ├── app.js
  ├── app.json
  ├── project.swan.json
  └── components
      └── custom
          ├── custom.swan
          ├── custom.css
          ├── custom.js
          └── custom.json
</pre>

<p>
  Components have their own lifecycles too. For example, in the JavaScript file for a custom component, the developer can:
</p>

<pre class="example js" title="JavaScript file in a custom component in Baidu Smart Programs">
  Component({
      // ...
      pageLifetimes: {
          show: function() {
          // Triggered when the page where the component is located is displayed
          },
          hide: function() {
          // Triggered when the page where the component is located is hidden
          }
      }
      // ...
  });
</pre>

    </section>
  
  </section>


  <section id="packaging">
    <h2>
      Packaging
    </h2>

    <p>
      Developers can divide the MiniApp into different sub-packages, and users can load them as needed when using the MiniApp. Dividing a MiniApp into reasonable sub-packages according to business characteristics can increase the loading speed of MiniApp and optimize user experience.
    </p>

    <p>
      In addition, through the manifest file or MiniApp APIs, developers can preload some sub-packages when the user accesses a certain page of the MiniApp.
    </p>

    <p>
      See also the <a href="https://github.com/w3c/miniapp/blob/gh-pages/specs/packaging/docs/explainer.md">packaging explainer</a> for a primer.
    </p>
  </section>

  <section id="runtime">
    <h2>
      Runtime
    </h2>

    <p>
      Different MiniApp implementations have different runtime environments. Here are a few examples:
    </p>

    <section id="wechat">
      <h2>
        WeChat Mini Programs
      </h2>

      <p>
        WeChat Mini Programs run on multiple platforms: iOS, Android, Windows, macOS, and WeChat's developer tools for debugging. The script execution environment and the environment used to render non-native components in these platforms are all different.
      </p>

      <p>
        Because the CSS and ECMAScript features supported by the these environment are different, developers need to use feature detection. WeChat Mini Programs provide built-in polyfills for some features to mitigate the interoperability issue.
      </p>

        <section>
          <h2>
            iOS
          </h2>

          <p>
            The JavaScript code in the logic layer of the MiniApp runs in <a href="https://developer.apple.com/documentation/javascriptcore">JavaScriptCore</a>, and the view layer is rendered in WKWebView.
          </p>
        </section>

        <section>
          <h2>
            Android
          </h2>

          <p>
            The JavaScript code in the logic layer of the MiniApp runs in <a href="https://v8.dev/">V8</a>, and the view layer is rendered in Tencent's X5/XWeb browser engine (based on Chromium).
          </p>
        </section>

        <section>
          <h2>
            DevTools
          </h2>

          <p>
            The JavaScript code in the logic layer of the MiniApp runs in <a href="https://nwjs.io/">NW.js</a> (which is based on Chromium and Node.js), and the view layer is rendered by Chromium.
          </p>

        </section>
      </section>

    <section id="baidu">
      <h2>
        Baidu Smart Programs
      </h2>

      <p>
        Baidu Smart Programs run on three platforms: iOS, Android, and Baidu's developer tools for debugging. The script execution environment and the environment used to render non-native components in these three platforms are different.
      </p>

      <p>
        Because the CSS and ECMAScript features supported by the three environment are different, developers need to use feature detection. Baidu Smart Programs provide built-in polyfills for some features to mitigate the interoperability issue.
      </p>

        <section>
          <h2>
            iOS
          </h2>

          <p>
            In the legacy version, the logic layer and view layer of the MiniApp were all running in the WebView and rendered.
          </p>

          <p>
            In the new version, the JavaScript code in the logic layer of the MiniApp runs in <a href="https://developer.apple.com/documentation/javascriptcore">JavaScriptCore</a>, and the view layer is rendered in WebView.
          </p>
        </section>

        <section>
          <h2>
            Android
          </h2>

          <p>
            In the legacy version, the logic layer and view layer of the MiniApp were all running in the WebView and rendered.
          </p>

          <p>
            In the new version, the JavaScript code in the logic layer of the MiniApp runs in <a href="https://v8.dev/">V8</a>, and the view layer is rendered in the WebView based using Baidu's T7 browser engine.
          </p>
        </section>

        <section>
          <h2>
            DevTools
          </h2>

          <p>
            The JavaScript code in the logic layer of the MiniApp runs in Electron, and the view layer is rendered by Chromium.
          </p>

        </section>

    </section>

    <section id="360">
      <h2>
        360 Mini Programs
      </h2>

      <p>
        360 Mini Programs runs in <a href="https://en.wikipedia.org/wiki/360_Secure_Browser">360 Secure Browser</a> on Windows.
      </p>
  </section>
  </section>

  <section id="lifecycle">
    <h2>
      Lifecycle
    </h2>

    <p>
      MiniApps implementations provides some lifecycle events and the process to manage the whole MiniApp and each page's lifecycle. See the <a href="https://w3c.github.io/miniapp/specs/lifecycle/">MiniApp Lifecycle</a> specification for a typical example.
    </p>

    <p>
      There are two ways to open a MiniApp:
    </p>

    <ul>
      <li>Cold launch: when the user opens the MiniApp for the first time (or the user exited the MiniApp for a long time, or opened too many MiniApps, causing this MiniApp to be destroyed);</li>
      <li>Hot launch: when the user reopens a MiniApp within a certain period of time;</li>
    </ul>

    <p>
      When the MiniApp is cold-launched, the hosting platform will use the local package to load the MiniApp, and at the same time, it will automatically detect whether there is a new package version in the cloud and download it asynchronously. After the download is complete, the new version of the package will be used when the user triggers a cold launch next time.
    </p>
  </section>

  <section id="api">
    <h2>
      APIs
    </h2>

    <p>
      MiniApp platforms usually provide their own APIs, some have corresponding web APIs, some do not. <a href="https://w3c.github.io/miniapp/white-paper/comparison.html">See a comparison here.</a>
    </p>

  </section>

  <section id="perf">
    <h2>
      Performance
    </h2>

    <section>
      <h2>Snapshot</h2>

    <p>
      Some MiniApp implementations like <a href="https://www.quickapp.cn/">Quick Apps</a> can perform a pre-rendering process on some pages in the cloud to generate a rendering intermediate format called snapshot. The snapshot format is very small after compression. For example, a 50K JavaScript file generates a ~3K snapshot.
    </p>

    <p>
      Since the snapshot file is very small, it can be distributed as part of the MiniApp metadata. For example, when a user searches for a MiniApp in the app store, the snapshot has been loaded along with the name of the MiniApp, package download link and other information.
    </p>

    <p>
      When the MiniApp is loaded and started for the first time, the download URL of the package and the snapshot file are passed to the MiniApp engine. When the engine requests to download the MiniApp package, it loads and parses the snapshot and renders it. When the package download is complete, the standard rendering process continues on the basis of the snapshot.
    </p>

  </section>

  <section>
    <h2>Virtual DOM</h2>

    <p>
      The page rendering of MiniApps often uses virtual DOM to ensure that only the changed data are updated when the page is updated. In web apps, virtual DOM is usually implemented with JavaScript, which consumes a lot of CPU and is not very efficient.
    </p>

    <p>
      Some MiniApp engines use WebAssembly to implement the core logic of virtual DOM, and modifies the JavaScript engine to improve the performance of calls between JavaScript and WebAssembly.
    </p>

  </section>

  </section>

  <section id="security-and-privacy">
    <h2>
      Security and privacy
    </h2>

    <p>
      Since MiniApps run in the hosting platform (aka user agent), in a native app people only care about whether there are vulnerabilities in the app itself, in a MiniApp people also need to know whether the hosting platform is secure.
    </p>

    <figure id="fig-miniapp-user-agent">
      <span style="text-align:center;"><img src="images/miniapp-user-agent.svg" alt="The relationship between MiniApps and the user agent." width="600"></span>
      <figcaption>
        The relationship between MiniApps and the user agent is similar to the relationship between a native app and the operating system, or the relationship between a web app and the brwoser.
      </figcaption>
    </figure>

    <p>
      Native apps will directly invoke system APIs, so many vulnerabilities are related to the operating system version, such as the WebView version in the user's operating system. However, beacuse some MiniApp implementations use their own browser engines (see [[[#runtime]]]), if the engine mitigates the vulnerability, there is no need to consider the impact of this vulnerability even on low-version Android systems. On the other hand, if there is a vulnerability specific to the browser engine in the MiniApp hosting platform, it will affect the MiniApps but not other parts of the system.
    </p>

    <p>
      Since MiniApps can not access DOM and the global object <code>window</code> (by seperating the view layer and the logical layer execution environment), and can only use the APIs and components the user agents provide, so it is not possible (or very difficult) for malicious code to jump to a random web page or MiniApp, or change the content on the UI. Since there are MiniApps components that can display sensitive data like username, avatar, gender, and geolocation etc., if developers can manipulate the DOM, it means that they can get user's sensitive information at will.
    </p>

    <p>
      Since most MiniApp implementations disallow dynamic code loading like <code>eval</code>, XSS is very difficult (or impossible).
    </p>

    <p>
      MiniApps usually have a domain name safelist, to permit scripts contained in a MiniApp to access data from a URL only when the domain name is in the safelist.
    </p>

    <p>
      Since MiniApps restrict the use of cookies, CSRF attacks is harder in MiniApps than normal web apps.
    </p>
  </section>


</body>
</html>
